{
  "api/Wolfgang.Extensions.IAsyncEnumerable.IAsyncEnumerableExtensions.html": {
    "href": "api/Wolfgang.Extensions.IAsyncEnumerable.IAsyncEnumerableExtensions.html",
    "title": "Class IAsyncEnumerableExtensions | Wolfgang.Extensions.IAsyncEnumerable Documentation",
    "summary": "Class IAsyncEnumerableExtensions Namespace Wolfgang.Extensions.IAsyncEnumerable Assembly Wolfgang.Extensions.IAsyncEnumerable.dll A collection of extension methods for IAsyncEnumerable{T}. public static class IAsyncEnumerableExtensions Inheritance object IAsyncEnumerableExtensions Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods ChunkAsync<T>(IAsyncEnumerable<T>, int, CancellationToken) Splits an IAsyncEnumerable{T} into chunks of a specified maximum size. public static IAsyncEnumerable<ICollection<T>> ChunkAsync<T>(this IAsyncEnumerable<T> source, int maxChunkSize, CancellationToken token = default) Parameters source IAsyncEnumerable<T> The source IAsyncEnumerable{T} to chunk. maxChunkSize int The maximum size of each chunk. token CancellationToken A cancellation token to cancel the operation. Returns IAsyncEnumerable<ICollection<T>> An IAsyncEnumerable{ICollection{T}} representing the chunks. Type Parameters T The type of elements in the IAsyncEnumerable{T}. Exceptions ArgumentNullException Thrown when source is null. ArgumentOutOfRangeException Thrown when maxChunkSize is less than or equal to zero."
  },
  "api/Wolfgang.Extensions.IAsyncEnumerable.html": {
    "href": "api/Wolfgang.Extensions.IAsyncEnumerable.html",
    "title": "Namespace Wolfgang.Extensions.IAsyncEnumerable | Wolfgang.Extensions.IAsyncEnumerable Documentation",
    "summary": "Namespace Wolfgang.Extensions.IAsyncEnumerable Classes IAsyncEnumerableExtensions A collection of extension methods for IAsyncEnumerable{T}."
  },
  "api/index.html": {
    "href": "api/index.html",
    "title": "API Reference | Wolfgang.Extensions.IAsyncEnumerable Documentation",
    "summary": "API Reference Browse the full API surface for Wolfgang.Extensions.IAsyncEnumerable. Use the table of contents to navigate to namespaces, classes, and individual extension methods."
  },
  "docs/getting-started.html": {
    "href": "docs/getting-started.html",
    "title": "Getting Started | Wolfgang.Extensions.IAsyncEnumerable Documentation",
    "summary": "Getting Started This guide will help you install and start using Wolfgang.Extensions.IAsyncEnumerable in your .NET projects. Installation Using .NET CLI Add the package to your project using the .NET CLI: dotnet add package Wolfgang.Extensions.IAsyncEnumerable Using Package Manager Console In Visual Studio, use the Package Manager Console: Install-Package Wolfgang.Extensions.IAsyncEnumerable Using Visual Studio NuGet Package Manager Right-click your project in Solution Explorer Select \"Manage NuGet Packages...\" Search for \"Wolfgang.Extensions.IAsyncEnumerable\" Click \"Install\" Note: The NuGet package is coming soon to NuGet.org. Check the GitHub repository for the latest status. Prerequisites The library supports multiple .NET versions: .NET Framework 4.6.2 or later .NET Standard 2.0 compatible projects .NET 8.0 or later .NET 10.0 or later Basic Usage Import the Namespace Add the using directive to your C# file: using Wolfgang.Extensions.IAsyncEnumerable; Example: Chunking an Async Stream The most common use case is processing a large async stream in batches: using System; using System.Collections.Generic; using System.Threading; using System.Threading.Tasks; using Wolfgang.Extensions.IAsyncEnumerable; public class Example { public async Task ProcessDataAsync(CancellationToken cancellationToken = default) { // Get an async stream from a database, API, or other source IAsyncEnumerable<DataRecord> dataStream = GetAsyncDataStream(); // Process the stream in chunks of 100 await foreach (var chunk in dataStream.ChunkAsync(maxChunkSize: 100, token: cancellationToken)) { Console.WriteLine($\"Processing batch of {chunk.Count} records\"); // Process the batch (e.g., bulk insert to database) await ProcessBatchAsync(chunk); } } private async IAsyncEnumerable<DataRecord> GetAsyncDataStream() { // Simulate an async data source for (int i = 0; i < 1000; i++) { await Task.Delay(10); // Simulate async operation yield return new DataRecord { Id = i }; } } private async Task ProcessBatchAsync(ICollection<DataRecord> batch) { // Simulate batch processing await Task.Delay(100); Console.WriteLine($\"Processed {batch.Count} records\"); } } public record DataRecord { public int Id { get; init; } } ChunkAsync Method Details Method Signature public static async IAsyncEnumerable<ICollection<T>> ChunkAsync<T>( this IAsyncEnumerable<T> source, int maxChunkSize, [EnumeratorCancellation] CancellationToken token = default) Parameters source: The source IAsyncEnumerable<T> to chunk maxChunkSize: Maximum number of elements in each chunk (must be > 0) token: Optional cancellation token to cancel the operation Returns An IAsyncEnumerable<ICollection<T>> where each element is a collection containing up to maxChunkSize items from the source. Important Notes Last Chunk Size: The last chunk may contain fewer than maxChunkSize elements if the source doesn't divide evenly Cancellation: Pass a CancellationToken to enable responsive cancellation of long-running operations Thread Safety: The method is safe to use with async streams from any source Memory Efficiency: Each chunk is yielded as soon as it's full, minimizing memory overhead Advanced Examples Example 1: Database Batch Insert public async Task BulkInsertAsync(IAsyncEnumerable<User> users, CancellationToken ct) { await foreach (var batch in users.ChunkAsync(maxChunkSize: 500, token: ct)) { // Use batch insert for better performance await _dbContext.Users.AddRangeAsync(batch, ct); await _dbContext.SaveChangesAsync(ct); Console.WriteLine($\"Inserted {batch.Count} users\"); } } Example 2: API Rate Limiting public async Task ProcessApiRequests(IAsyncEnumerable<ApiRequest> requests, CancellationToken ct) { await foreach (var batch in requests.ChunkAsync(maxChunkSize: 10, token: ct)) { // Process batch concurrently, respecting API rate limits var tasks = batch.Select(req => _apiClient.SendAsync(req, ct)); await Task.WhenAll(tasks); // Wait before next batch to respect rate limits await Task.Delay(TimeSpan.FromSeconds(1), ct); } } Example 3: Parallel Processing with Controlled Concurrency public async Task ProcessWithControlledConcurrency( IAsyncEnumerable<WorkItem> items, CancellationToken ct) { await foreach (var batch in items.ChunkAsync(maxChunkSize: 20, token: ct)) { // Process each batch item in parallel, but limit total concurrency var tasks = batch.Select(item => ProcessItemAsync(item, ct)); await Task.WhenAll(tasks); } } Error Handling Always use try-catch blocks when working with async enumerables: public async Task SafeProcessingAsync(IAsyncEnumerable<DataItem> items, CancellationToken ct) { try { await foreach (var chunk in items.ChunkAsync(maxChunkSize: 100, token: ct)) { await ProcessChunkAsync(chunk); } } catch (OperationCanceledException) { Console.WriteLine(\"Processing was cancelled\"); throw; // Re-throw to let caller handle cancellation } catch (Exception ex) { Console.WriteLine($\"Error processing items: {ex.Message}\"); throw; } } Performance Tips Choose Appropriate Chunk Sizes: Balance between memory usage and processing efficiency Smaller chunks (10-50): Lower memory, more overhead Medium chunks (100-500): Good balance for most scenarios Large chunks (1000+): Better throughput, higher memory usage Use Cancellation Tokens: Always pass cancellation tokens for responsive applications Avoid Blocking Operations: Never use Task.Wait() or Task.Result - always use await Profile Your Code: Use BenchmarkDotNet or similar tools to measure performance in your specific scenario Next Steps Read the Introduction to learn more about the library's philosophy Check the GitHub repository for examples and source code Review CONTRIBUTING.md if you'd like to contribute Need Help? Issues: Report bugs or request features on GitHub Issues Discussions: Ask questions in GitHub Discussions Source Code: View the source on GitHub"
  },
  "docs/introduction.html": {
    "href": "docs/introduction.html",
    "title": "Introduction | Wolfgang.Extensions.IAsyncEnumerable Documentation",
    "summary": "Introduction What is Wolfgang.Extensions.IAsyncEnumerable? Wolfgang.Extensions.IAsyncEnumerable is a high-performance .NET library that provides extension methods for working with IAsyncEnumerable<T>. It's designed to make asynchronous stream processing easier, more efficient, and more maintainable. Why Use This Library? Working with asynchronous streams in .NET can be challenging. While IAsyncEnumerable<T> provides a powerful abstraction for asynchronous sequences, common operations like chunking, batching, and transformation often require repetitive boilerplate code. This library provides: Production-Ready Extensions: Battle-tested extension methods for common async enumerable operations High Performance: Optimized implementations with minimal allocations Comprehensive Test Coverage: Extensive unit tests ensure reliability Multi-Framework Support: Works with .NET Framework 4.6.2, .NET Standard 2.0, .NET 8.0, and .NET 10.0 Strict Code Quality: Enforced through 7 specialized analyzers and async-first patterns Key Features ChunkAsync The ChunkAsync extension method allows you to split an asynchronous stream into fixed-size chunks for efficient batch processing: using Wolfgang.Extensions.IAsyncEnumerable; // Process a large async stream in batches of 100 await foreach (var batch in largeAsyncStream.ChunkAsync(maxChunkSize: 100)) { // Each batch is an ICollection<T> with up to 100 items await ProcessBatchAsync(batch); } Benefits: Enables efficient batch processing of async streams Reduces memory overhead by processing data in manageable chunks Supports cancellation tokens for responsive applications Handles edge cases like incomplete final chunks automatically Async-First Design This library is built with an async-first philosophy: All operations are truly asynchronous and non-blocking No usage of Task.Wait(), Task.Result, or other blocking operations Enforced through banned API analyzers and code quality rules Optimized for async/await patterns throughout Code Quality Standards The library maintains exceptional code quality through: 7 Specialized Analyzers: Including AsyncFixer, Roslynator, and SonarAnalyzer Banned API Enforcement: Prevents usage of synchronous and obsolete APIs Comprehensive Testing: High test coverage with both unit and integration tests Strict Formatting: Enforced through .editorconfig and dotnet format Continuous Integration: Automated builds, tests, and quality checks on every commit Use Cases This library is ideal for: Batch Processing: Processing large datasets in manageable chunks Stream Processing: Working with continuous data streams from APIs, databases, or message queues Rate Limiting: Controlling the rate of operations on async streams Resource Management: Managing memory usage when processing large collections asynchronously Performance Optimization: Improving throughput in async data pipelines Next Steps Ready to get started? Check out the Getting Started guide to install and use the library in your project."
  },
  "index.html": {
    "href": "index.html",
    "title": "Wolfgang.Extensions.IAsyncEnumerable | Wolfgang.Extensions.IAsyncEnumerable Documentation",
    "summary": "Wolfgang.Extensions.IAsyncEnumerable High-performance, production-grade extension methods for IAsyncEnumerable<T> with comprehensive test coverage and strict code quality enforcement. Tip \uD83D\uDCD8 API Reference: Browse the full API documentation \uD83D\uDCE6 Installation dotnet add package Wolfgang.Extensions.IAsyncEnumerable NuGet Package: Coming soon to NuGet.org \uD83D\uDE80 Quick Start using Wolfgang.Extensions.IAsyncEnumerable; // Chunk an async stream into batches await foreach (var chunk in asyncStream.ChunkAsync(maxChunkSize: 100, token: cancellationToken)) { // Process each chunk (ICollection<T>) await ProcessBatchAsync(chunk); } ✨ Features Current Extension Methods ChunkAsync<T> Splits an IAsyncEnumerable<T> into fixed-size chunks for batch processing. public static async IAsyncEnumerable<ICollection<T>> ChunkAsync<T>( this IAsyncEnumerable<T> source, int maxChunkSize, CancellationToken token = default) Parameters: source - The source async enumerable to chunk maxChunkSize - Maximum size of each chunk (must be > 0) token - Optional cancellation token Returns: An async enumerable of collections, where each collection contains up to maxChunkSize elements. Example: var numbers = GetAsyncNumbers(); // IAsyncEnumerable<int> await foreach (var batch in numbers.ChunkAsync(50)) { Console.WriteLine($\"Processing batch of {batch.Count} items\"); // Last batch may be smaller than 50 } \uD83C\uDFAF Target Frameworks This library supports multiple .NET versions: .NET Framework 4.6.2 (net462) .NET Standard 2.0 (netstandard2.0) .NET 8.0 (net8.0) .NET 10.0 (net10.0) \uD83D\uDD0D Code Quality & Static Analysis This project enforces strict code quality standards through 7 specialized analyzers and custom async-first rules: Analyzers in Use Microsoft.CodeAnalysis.NetAnalyzers - Built-in .NET analyzers for correctness and performance Roslynator.Analyzers - Advanced refactoring and code quality rules AsyncFixer - Async/await best practices and anti-pattern detection Microsoft.VisualStudio.Threading.Analyzers - Thread safety and async patterns Microsoft.CodeAnalysis.BannedApiAnalyzers - Prevents usage of banned synchronous APIs Meziantou.Analyzer - Comprehensive code quality rules SonarAnalyzer.CSharp - Industry-standard code analysis Async-First Enforcement This library uses BannedSymbols.txt to prohibit synchronous APIs and enforce async-first patterns: Blocked APIs Include: ❌ Task.Wait(), Task.Result - Use await instead ❌ Thread.Sleep() - Use await Task.Delay() instead ❌ Synchronous file I/O (File.ReadAllText) - Use async versions ❌ Synchronous stream operations - Use ReadAsync(), WriteAsync() ❌ Parallel.For/ForEach - Use Task.WhenAll() or Parallel.ForEachAsync() ❌ Obsolete APIs (WebClient, BinaryFormatter) Why? To ensure all code is truly async and non-blocking for optimal performance in async contexts. \uD83D\uDEE0️ Building from Source Prerequisites .NET 8.0 SDK or later Optional: PowerShell Core for formatting scripts Build Steps # Clone the repository git clone https://github.com/Chris-Wolfgang/IAsyncEnumerable-Extensions.git cd IAsyncEnumerable-Extensions # Restore dependencies dotnet restore # Build the solution dotnet build --configuration Release # Run tests dotnet test --configuration Release # Run code formatting (PowerShell Core) pwsh ./format.ps1 Code Formatting This project uses .editorconfig and dotnet format: # Format code dotnet format # Verify formatting (as CI does) dotnet format --verify-no-changes \uD83D\uDCDA Documentation GitHub Repository: https://github.com/Chris-Wolfgang/IAsyncEnumerable-Extensions API Documentation: Browse the API reference in the navigation menu Getting Started: See the Getting Started guide Introduction: Learn more in the Introduction \uD83E\uDD1D Contributing Contributions are welcome! Please see CONTRIBUTING.md for: Code quality standards Build and test instructions Pull request guidelines Analyzer configuration details \uD83D\uDCC4 License This project is licensed under the MIT License. See the LICENSE file for details. \uD83D\uDE4F Acknowledgments Built with: Microsoft.Bcl.AsyncInterfaces for backward compatibility Comprehensive analyzer packages for code quality enforcement .NET async/await patterns for optimal performance"
  }
}